# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**晋文源试卷管理系统** (Jinwenyuan Paper Management System) - A full-stack application for managing educational exam papers, question banks, and automated Word document parsing.

**Monorepo Structure:**
- `my-app/` - Frontend: Umi Max 4 + React + Ant Design Pro
- `backend/` - Backend: FastAPI + PostgreSQL + SQLAlchemy

**Core Feature:** Upload Word exam papers → Automated parsing into structured questions → User proofreading → Save to question bank database.

---

## Development Commands

### Frontend (my-app/)
```bash
cd my-app
npm run dev          # Start dev server at http://localhost:8000
npm run build        # Production build
npm run format       # Format with Prettier
```

### Backend (backend/)
```bash
cd backend
source venv/bin/activate              # Windows: venv\Scripts\activate
pip install -r requirements.txt

# Database setup
docker-compose up -d                  # Start PostgreSQL
alembic upgrade head                  # Apply migrations
alembic revision --autogenerate -m "description"  # Create migration
alembic downgrade -1                  # Rollback migration

# Run server
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

# Testing (when tests exist)
pytest
```

**API Documentation:** http://localhost:8000/docs (auto-generated by FastAPI)

---

## Architecture

### Frontend (my-app/)

**Tech Stack:** Umi Max 4 (React framework) + Ant Design Pro Components + TypeScript

**Key Conventions:**
- Convention-based routing from `config/routes.ts`
- Runtime config in `src/app.tsx` (layout, initial state, breadcrumbs)
- Build config in `.umirc.ts` (proxies `/api` to backend at port 8000)
- CSS Modules for styling (`import styles from './index.less'`)

**Project Structure:**
```
my-app/src/
├── pages/                    # Page components (route-based)
│   ├── PaperUpload/          # Word upload workflow
│   │   ├── index.tsx         # Upload page with form
│   │   └── Edit/             # Full-screen proofreading page
│   ├── ContentCenter/        # Product, subject, tag management
│   └── QuestionBank/         # Question bank features
├── services/                 # API service layer
│   ├── paperUpload.ts        # Paper upload/parsing/submit APIs
│   ├── tagSystem.ts          # Tag categories and knowledge tree
│   └── questionBankTask.ts
├── components/               # Shared components
│   └── RichTextEditor/       # wangEditor wrapper
├── models/                   # Global state (Umi data flow)
└── app.tsx                   # Runtime config
```

**Important Files:**
- `config/routes.ts` - Route definitions (supports nested routes, `layout: false` for full-screen pages)
- `.umirc.ts` - Build config (API proxy, mock disabled)
- `src/app.tsx` - Layout config and breadcrumb rendering

### Backend (backend/)

**Tech Stack:** FastAPI + PostgreSQL + SQLAlchemy ORM + Alembic migrations + python-docx

**Project Structure:**
```
backend/app/
├── api/v1/                   # API endpoints
│   └── paper.py              # Upload, result, submit endpoints
├── core/                     # Core functionality
│   ├── parser/               # Word parsing modules ⭐
│   │   ├── docx_parser.py         # Document loader
│   │   ├── structure_parser.py    # Question boundary detection
│   │   ├── content_parser.py      # Content extraction
│   │   ├── formula_parser.py      # OMML → MathML conversion
│   │   ├── image_parser.py        # Image extraction
│   │   └── token_generator.py     # HTML generation
│   └── task_manager.py       # In-memory async task tracking
├── models/
│   ├── database/             # SQLAlchemy ORM models
│   │   ├── paper.py
│   │   ├── question.py
│   │   ├── question_content.py
│   │   └── image.py
│   └── schemas/              # Pydantic models for API
│       └── question.py
├── services/                 # Business logic layer
│   ├── parse_service.py      # Parsing orchestration ⭐
│   ├── paper_service.py      # Paper CRUD
│   └── question_service.py   # Question CRUD
├── config.py                 # pydantic-settings config
├── database.py               # DB connection and session
└── main.py                   # FastAPI app entry point
```

---

## Word Document Parsing Architecture

The core feature of this system is parsing Word exam papers into structured questions. This is a **complex multi-stage pipeline**.

### Parsing Stages

**Stage 1: Upload** (`POST /api/paper/upload`)
- User uploads .docx file + metadata (name, subject, year, region, type)
- Backend saves to `storage/uploads/`, creates task ID (UUID)
- Starts background parsing task via FastAPI BackgroundTasks
- Returns `{ taskId }` immediately

**Stage 2: Document Parsing** (`ParseService` orchestrates 6 specialized parsers)
1. **DocxParser** - Loads Word document with python-docx
2. **ImageParser** - Extracts embedded images to `storage/images/{taskId}/`
3. **StructureParser** - Detects question boundaries and structure
4. **ContentParser** - Extracts stem/options/answer/analysis/difficulty/knowledge points
5. **FormulaParser** - Converts OMML math formulas to MathML HTML
6. **TokenGenerator** - Assembles HTML output with formulas and images

**Stage 3: Polling** (`GET /api/paper/result/{taskId}`)
- Frontend polls every 1-2 seconds until status becomes "success"
- TaskManager stores results in-memory (keyed by taskId)

**Stage 4: Proofreading** (`/question-bank/word-upload/edit`)
- Full-screen three-column layout (layout: false)
- Left: Original document preview (mock)
- Center: Question cards with rich text editors (wangEditor)
- Right: Attribute editing panel (type, difficulty, knowledge points)

**Stage 5: Submit** (`POST /api/paper/submit`)
- Saves corrected questions to PostgreSQL via PaperService + QuestionService
- Saves to tables: `papers`, `questions`, `question_contents`, `images`

### Three Question Parsing Modes

The parser handles three distinct question formats (see `WORD_PARSING_GUIDE.md` for details):

1. **Mode 1: Single Question** - Standard questions with one answer block
   - Format: `1. 题干\nA. 选项\n【答案】D\n【难度】0.65`

2. **Mode 2: Question Group** - Material + multiple numbered questions (3, 4, 5...)
   - Format: `材料...\n3. 题干A\n4. 题干B\n【答案】3．B  4．A`
   - Returns parent QuestionItem with children array (JYeoo style)
   - Each child has relative numbering (1, 2, 3...)

3. **Mode 3: Material + Sub-questions** - Material + parenthetical sub-questions (1), (2), (3)...
   - Format: `7. 主题干\n(1) 小题1\n(2) 小题2\n【答案】(1)答案1 (2)答案2`
   - Returns parent QuestionItem with children array

**Mode Detection Logic** (`parse_service.py:_process_material_question`):
- If first sub-question number starts with `(` → Mode 3
- Otherwise → Mode 2

**Content Extraction Features:**
- Supports both `【解析】` and `【详解】` for analysis blocks
- Difficulty normalization: Converts 0-1 decimals to 1-5 integer scale (0.65 → 3)
- Grouped answer parsing: `3．B  4．A` → `{"3": "B", "4": "A"}`
- Sub-question answer parsing: `(1)答案1\n(2)答案2` → `{"(1)": "答案1", "(2)": "答案2"}`
- Material keyword detection: "阅读下列材料，完成下面小题", "完成下列题目", etc.

---

## Key Patterns and Workflows

### Frontend API Service Pattern
All API calls use `@umijs/max` request utility:
```typescript
import { request } from '@umijs/max';

export async function uploadPaper(file: File, metadata: PaperMetadata) {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('metadata', JSON.stringify(metadata));
  return request<ApiResponse<{ taskId: string }>>('/api/paper/upload', {
    method: 'POST',
    data: formData,
  });
}
```

All responses follow format: `{ success: boolean, message: string, data: T }`

### Backend Service Layer Pattern
Services receive DB session via dependency injection:
```python
class PaperService:
    def __init__(self, db: Session):
        self.db = db

    def create_paper(self, task_id: str, metadata: PaperMetadata) -> Paper:
        try:
            paper = Paper(task_id=task_id, paper_metadata=metadata.model_dump())
            self.db.add(paper)
            self.db.commit()
            return paper
        except Exception as e:
            self.db.rollback()
            raise HTTPException(status_code=500, detail=str(e))
```

### Backend API Endpoint Pattern
```python
@router.post("/upload", response_model=ApiResponse[UploadResponse])
async def upload_paper(
    background_tasks: BackgroundTasks,
    file: UploadFile = File(...),
    db: Session = Depends(get_db)
):
    # Validate, process, schedule background task
    return ApiResponse(success=True, message="Success", data=...)
```

### Database Model Pattern
```python
class Question(Base):
    __tablename__ = "questions"

    id = Column(Integer, primary_key=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # JSON columns for flexible metadata
    metadata = Column(JSON, nullable=True)
```

### Task Manager Pattern
In-memory task tracking for async operations:
- States: `pending` → `processing` → `success`/`failed`
- `TaskManager` in `core/task_manager.py`
- Frontend polls `/api/paper/result/{taskId}` until completion

---

## Important Implementation Notes

### Frontend
- **TypeScript**: `tsconfig.json` extends from `.umi/tsconfig.json` (auto-generated, don't edit manually)
- **Rich Text Editor**: Uses `@wangeditor/editor-for-react` for question content editing
- **Mock Data**: Disabled in `.umirc.ts` - use real backend during development
- **Prettier**: Auto-formatting configured with 80 char width, single quotes, trailing commas
- **Code Quality**: Husky + lint-staged pre-commit hooks

### Backend
- **Configuration**: Environment variables in `.env` (copy from `.env.example`), accessed via `get_settings()` singleton
- **Database**: PostgreSQL in Docker (port 5432), always use `get_db()` dependency injection
- **Error Handling**: Use `HTTPException` with appropriate status codes (400, 404, 500), always rollback on error
- **Attribute Block Recognition**: Parsers support `【答案】`, `【难度】`, `【知识点】`, `【解析】`, `【详解】`
- **Difficulty Normalization**: `normalize_difficulty()` converts 0-1 decimals to 1-5 integers
- **Formula Handling**: OMML formulas converted to MathML HTML for web display
- **Image Handling**: Extracted to `/api/paper/images/{taskId}/{imageId}`, classified as inline/block

### Parsing Updates
See `WORD_PARSING_GUIDE.md` and `backend/PARSING_UPDATES.md` for detailed parsing rules and recent updates. Key recent improvements:
- Support for `【详解】` in addition to `【解析】`
- Difficulty value normalization (0.65 → 3)
- Grouped answer parsing for question groups
- Sub-question answer parsing for material questions
- Enhanced material keyword detection

---

## Common Development Workflows

### Adding a New Frontend Page
1. Create component in `src/pages/[PageName]/index.tsx`
2. Add route in `config/routes.ts` with path, name, icon, component
3. Create service file in `src/services/` if API calls needed
4. Use `PageContainer` from `@ant-design/pro-components` for layout

### Adding a New Backend API Endpoint
1. Define Pydantic schemas in `models/schemas/`
2. Create service class in `services/` for business logic
3. Add router function in `api/v1/` directory
4. Include router in `main.py` if new module
5. Test at http://localhost:8000/docs

### Database Schema Changes
1. Modify SQLAlchemy models in `models/database/`
2. Create migration: `alembic revision --autogenerate -m "description"`
3. Review generated migration file in `migrations/versions/`
4. Apply migration: `alembic upgrade head`
5. Test rollback: `alembic downgrade -1`

### Modifying Word Parsing Rules
1. Review current rules in `WORD_PARSING_GUIDE.md`
2. Update parser in `backend/app/core/parser/` (likely `content_parser.py` or `structure_parser.py`)
3. Update orchestration logic in `backend/app/services/parse_service.py` if needed
4. Test with real Word documents via upload endpoint
5. Document changes in `WORD_PARSING_GUIDE.md`

---

## Code Style Guidelines

### Frontend (TypeScript/React)
- **Import Order**: React → Third-party → Framework → Local services → CSS modules
- **File Naming**: PascalCase for components, camelCase for functions/services
- **Components**: Use `React.FC` type, define interfaces in service files, avoid `any`
- **API Calls**: Define in `services/` using `request()` from `@umijs/max`

### Backend (Python)
- **Import Order**: Standard library → Third-party → Local (absolute from `app.*`)
- **Naming**: PascalCase for classes, snake_case for functions/variables, UPPER_SNAKE_CASE for constants
- **Pydantic Schemas**: Use `Field()` with descriptions, `Config: populate_by_name = True` for camelCase
- **Services**: Always include proper error handling with `try/except` and DB rollback

---

## Reference Documentation

- `WORD_PARSING_GUIDE.md` - Complete parsing rules and question format specifications
- `AGENTS.md` - Previous guidance file with code style rules
- `backend/PARSING_UPDATES.md` - Detailed code updates for parsing improvements
- `backend/WORD_FORMAT_ANALYSIS.md` - Analysis of Word document formats
- `backend/PARSING_ISSUES_ANALYSIS.md` - Known parsing issues and solutions
- `my-app/CLAUDE.md` - Frontend-specific guidance (superseded by this file)
